import opik
from functools import wraps
import time
from typing import Any, Dict, Callable


def trace_agent_execution(func: Callable) -> Callable:
    """
    Decorator to trace agent execution with Opik
    
    Captures:
    - trace_id (auto-generated by Opik)
    - agent_name
    - input
    - output
    - latency
    """
    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        # Get agent name from method or kwargs
        agent_name = kwargs.get('agent_name', 'unknown_agent')
        input_data = kwargs.get('input_data', {})
        
        # Start timing
        start_time = time.time()
        
        # Create Opik trace
        with opik.start_as_current_trace(
            name=f"agent_execution_{agent_name}",
            input={"agent": agent_name, "input_data": input_data},
            tags=[agent_name, "agent_execution"],
            metadata={"function": func.__name__}
        ) as trace:
            try:
                # Execute the function
                result = func(*args, **kwargs)
                
                # Calculate latency
                latency_ms = (time.time() - start_time) * 1000
                
                # Update trace with output and metadata
                trace.output = result
                trace.metadata.update({
                    "latency_ms": latency_ms,
                    "status": "success"
                })
                
                return result
                
            except Exception as e:
                # Calculate latency even on error
                latency_ms = (time.time() - start_time) * 1000
                
                # Log error in trace
                trace.output = {"error": str(e)}
                trace.metadata.update({
                    "latency_ms": latency_ms,
                    "status": "error",
                    "error_type": type(e).__name__
                })
                
                # Re-raise the exception
                raise
    
    return wrapper
