import opik
from functools import wraps
import time
from typing import Any, Dict, Callable


def trace_agent_execution(func: Callable) -> Callable:
    """
    Decorator to trace agent execution with Opik
    
    Captures:
    - trace_id (auto-generated by Opik)
    - agent_name
    - input
    - output
    - latency
    """
    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        # Get agent name from method or kwargs
        agent_name = kwargs.get('agent_name', 'unknown_agent')
        input_data = kwargs.get('input_data', {})
        
        # Start timing
        start_time = time.time()
        
        # Create Opik trace
        with opik.start_as_current_trace(
            name=f"agent_execution_{agent_name}",
            input={"agent": agent_name, "input_data": input_data},
            tags=[agent_name, "agent_execution"],
            metadata={"function": func.__name__}
        ) as trace:
            try:
                # Execute the function
                result = func(*args, **kwargs)
                
                # Calculate latency
                latency_ms = (time.time() - start_time) * 1000
                
                # Extract ETA if available in result
                eta_days = None
                if isinstance(result, dict):
                    eta_days = result.get('eta_days')
                    # Also check nested result
                    if eta_days is None and 'result' in result:
                        nested_result = result['result']
                        if isinstance(nested_result, dict):
                            eta_days = nested_result.get('eta_days')
                
                # Update trace with output and metadata
                trace.output = result
                metadata_update = {
                    "latency_ms": latency_ms,
                    "status": "success"
                }
                
                # Add ETA to metadata if available
                if eta_days is not None:
                    metadata_update["eta_days"] = eta_days
                
                trace.metadata.update(metadata_update)
                
                return result
                
            except Exception as e:
                # Calculate latency even on error
                latency_ms = (time.time() - start_time) * 1000
                
                # Log error in trace
                trace.output = {"error": str(e)}
                trace.metadata.update({
                    "latency_ms": latency_ms,
                    "status": "error",
                    "error_type": type(e).__name__
                })
                
                # Re-raise the exception
                raise
    
    return wrapper
