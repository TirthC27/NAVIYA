-- ============================================
-- Skill Assessments Schema
-- Generated by SkillEvaluationAgent
-- ============================================

-- Drop existing tables for clean install
DROP TABLE IF EXISTS assessment_questions CASCADE;
DROP TABLE IF EXISTS assessment_responses CASCADE;
DROP TABLE IF EXISTS skill_assessments CASCADE;

-- ============================================
-- Main skill_assessments table
-- Stores evaluation results
-- ============================================

CREATE TABLE skill_assessments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    domain VARCHAR(20) NOT NULL CHECK (domain IN ('tech', 'medical')),
    skill_or_subject VARCHAR(200) NOT NULL,
    raw_score DECIMAL(5,2) NOT NULL CHECK (raw_score >= 0 AND raw_score <= 100),
    proficiency_level VARCHAR(20) NOT NULL CHECK (proficiency_level IN ('beginner', 'intermediate', 'advanced')),
    confidence_level VARCHAR(10) NOT NULL CHECK (confidence_level IN ('low', 'medium', 'high')),
    weak_areas JSONB DEFAULT '[]'::JSONB,
    recommendation TEXT,
    questions_json JSONB DEFAULT NULL,
    responses_json JSONB DEFAULT NULL,
    current_phase INTEGER,
    assessment_duration_seconds INTEGER,
    retake_available_at TIMESTAMPTZ DEFAULT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- Assessment questions table (optional detail)
-- Stores generated questions for review
-- ============================================

CREATE TABLE assessment_questions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assessment_id UUID NOT NULL REFERENCES skill_assessments(id) ON DELETE CASCADE,
    question_id VARCHAR(50) NOT NULL,
    question_text TEXT NOT NULL,
    options JSONB DEFAULT NULL,
    correct_answer TEXT NOT NULL,
    skill_tag VARCHAR(100),
    subject_tag VARCHAR(100),
    difficulty VARCHAR(20) DEFAULT 'medium',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- Assessment responses table
-- Stores user responses for analysis
-- ============================================

CREATE TABLE assessment_responses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    assessment_id UUID NOT NULL REFERENCES skill_assessments(id) ON DELETE CASCADE,
    question_id VARCHAR(50) NOT NULL,
    user_answer TEXT,
    is_correct BOOLEAN DEFAULT FALSE,
    time_taken_seconds INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- Indexes for Performance
-- ============================================

CREATE INDEX idx_skill_assessments_user 
    ON skill_assessments(user_id);

CREATE INDEX idx_skill_assessments_domain 
    ON skill_assessments(domain);

CREATE INDEX idx_skill_assessments_skill 
    ON skill_assessments(user_id, skill_or_subject);

CREATE INDEX idx_skill_assessments_created 
    ON skill_assessments(created_at DESC);

CREATE INDEX idx_skill_assessments_proficiency 
    ON skill_assessments(user_id, proficiency_level);

CREATE INDEX idx_skill_assessments_retake 
    ON skill_assessments(user_id, skill_or_subject, retake_available_at);

CREATE INDEX idx_assessment_questions_assessment 
    ON assessment_questions(assessment_id);

CREATE INDEX idx_assessment_responses_assessment 
    ON assessment_responses(assessment_id);

-- ============================================
-- Row Level Security (RLS)
-- ============================================

ALTER TABLE skill_assessments ENABLE ROW LEVEL SECURITY;
ALTER TABLE assessment_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE assessment_responses ENABLE ROW LEVEL SECURITY;

-- Users can view their own assessments
CREATE POLICY "Users can view own assessments" ON skill_assessments
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage assessments" ON skill_assessments
    FOR ALL USING (auth.role() = 'service_role');

-- Users can view their own questions
CREATE POLICY "Users can view own assessment questions" ON assessment_questions
    FOR SELECT USING (
        assessment_id IN (
            SELECT id FROM skill_assessments WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Service role can manage questions" ON assessment_questions
    FOR ALL USING (auth.role() = 'service_role');

-- Users can view their own responses
CREATE POLICY "Users can view own responses" ON assessment_responses
    FOR SELECT USING (
        assessment_id IN (
            SELECT id FROM skill_assessments WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Service role can manage responses" ON assessment_responses
    FOR ALL USING (auth.role() = 'service_role');

-- ============================================
-- Functions
-- ============================================

-- Function to check if retake is available
CREATE OR REPLACE FUNCTION can_retake_assessment(
    p_user_id UUID,
    p_skill_or_subject VARCHAR(200)
) RETURNS BOOLEAN AS $$
DECLARE
    v_retake_available TIMESTAMPTZ;
BEGIN
    SELECT retake_available_at
    INTO v_retake_available
    FROM skill_assessments
    WHERE user_id = p_user_id 
      AND skill_or_subject = p_skill_or_subject
    ORDER BY created_at DESC
    LIMIT 1;
    
    IF v_retake_available IS NULL THEN
        RETURN TRUE;
    END IF;
    
    RETURN NOW() >= v_retake_available;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get latest assessment for a skill
CREATE OR REPLACE FUNCTION get_latest_skill_assessment(
    p_user_id UUID,
    p_skill_or_subject VARCHAR(200)
) RETURNS TABLE (
    id UUID,
    raw_score DECIMAL,
    proficiency_level VARCHAR,
    confidence_level VARCHAR,
    weak_areas JSONB,
    recommendation TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sa.id,
        sa.raw_score,
        sa.proficiency_level,
        sa.confidence_level,
        sa.weak_areas,
        sa.recommendation,
        sa.created_at
    FROM skill_assessments sa
    WHERE sa.user_id = p_user_id 
      AND sa.skill_or_subject = p_skill_or_subject
    ORDER BY sa.created_at DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get skill progress over time
CREATE OR REPLACE FUNCTION get_skill_progress(
    p_user_id UUID,
    p_skill_or_subject VARCHAR(200),
    p_limit INTEGER DEFAULT 10
) RETURNS TABLE (
    assessment_id UUID,
    raw_score DECIMAL,
    proficiency_level VARCHAR,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sa.id,
        sa.raw_score,
        sa.proficiency_level,
        sa.created_at
    FROM skill_assessments sa
    WHERE sa.user_id = p_user_id 
      AND sa.skill_or_subject = p_skill_or_subject
    ORDER BY sa.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to calculate proficiency level from score
CREATE OR REPLACE FUNCTION calculate_proficiency(p_score DECIMAL)
RETURNS VARCHAR AS $$
BEGIN
    IF p_score < 40 THEN
        RETURN 'beginner';
    ELSIF p_score <= 70 THEN
        RETURN 'intermediate';
    ELSE
        RETURN 'advanced';
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ============================================
-- Views
-- ============================================

-- View for user skill summary
CREATE OR REPLACE VIEW v_user_skill_summary AS
SELECT 
    sa.user_id,
    sa.domain,
    sa.skill_or_subject,
    sa.raw_score,
    sa.proficiency_level,
    sa.confidence_level,
    sa.weak_areas,
    sa.created_at,
    ROW_NUMBER() OVER (
        PARTITION BY sa.user_id, sa.skill_or_subject 
        ORDER BY sa.created_at DESC
    ) as assessment_rank
FROM skill_assessments sa;

-- View for latest assessments per skill
CREATE OR REPLACE VIEW v_latest_skill_assessments AS
SELECT *
FROM v_user_skill_summary
WHERE assessment_rank = 1;

-- View for skill improvement tracking
CREATE OR REPLACE VIEW v_skill_improvement AS
SELECT 
    sa.user_id,
    sa.skill_or_subject,
    sa.domain,
    COUNT(*) as attempt_count,
    MIN(sa.raw_score) as lowest_score,
    MAX(sa.raw_score) as highest_score,
    AVG(sa.raw_score) as average_score,
    MAX(sa.raw_score) - MIN(sa.raw_score) as improvement,
    MAX(sa.created_at) as last_attempt
FROM skill_assessments sa
GROUP BY sa.user_id, sa.skill_or_subject, sa.domain;

-- View for weak areas aggregation
CREATE OR REPLACE VIEW v_user_weak_areas AS
SELECT 
    sa.user_id,
    sa.domain,
    jsonb_array_elements_text(sa.weak_areas) as weak_area,
    COUNT(*) as occurrence_count
FROM skill_assessments sa
WHERE sa.weak_areas IS NOT NULL 
  AND jsonb_array_length(sa.weak_areas) > 0
GROUP BY sa.user_id, sa.domain, jsonb_array_elements_text(sa.weak_areas)
ORDER BY occurrence_count DESC;

-- ============================================
-- Triggers
-- ============================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_assessment_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_skill_assessment_updated
    BEFORE UPDATE ON skill_assessments
    FOR EACH ROW
    EXECUTE FUNCTION update_assessment_timestamp();

-- ============================================
-- Comments
-- ============================================

COMMENT ON TABLE skill_assessments IS 'Stores skill evaluation results from SkillEvaluationAgent';
COMMENT ON TABLE assessment_questions IS 'Stores generated assessment questions for review and analysis';
COMMENT ON TABLE assessment_responses IS 'Stores user responses to assessment questions';
COMMENT ON COLUMN skill_assessments.retake_available_at IS 'Cooldown period before user can retake assessment';
COMMENT ON COLUMN skill_assessments.weak_areas IS 'JSONB array of identified weak areas from evaluation';
